using System;
using System.Linq;
using SharpPcap;
using System.CommandLine;
using System.CommandLine.Invocation;
using System.Globalization;
using System.Net;
using PacketDotNet;
#nullable enable
namespace ipk_sniffer
{
    class Program
    {
        /// <summary>
        /// Created header string of packet from packet header info
        /// </summary>
        /// <returns>Packet header</returns>
        public static string PacketHeader(DateTime arrivalTime, IPAddress sourceIpAddress, int? sourcePort,
            IPAddress destIpAddress, int? destPort, int dataLength)
        {
            var header = "";
            header += arrivalTime.ToString("yyyy-MM-dd'T'HH:mm:ss.fffzzz", DateTimeFormatInfo.InvariantInfo); //RFC3339 standard format
            header += $" {sourceIpAddress}";
            header += sourcePort == null ? "" : $" : {sourcePort}"; //icmp and arp have no port
            header += $" > {destIpAddress}";
            header += destPort == null ? "" : $" : {destPort}";
            header += $", length {dataLength} bytes\n\n";
            return header;
        }
        /// <summary>
        /// Edit format of packet data from printHex method to format required by project assignment
        /// </summary>
        /// <param name="data">Packet data formatted by PrintHex method</param>
        /// <returns>Packet data in format 'offset hexa ascii'</returns>
        public static string PacketDataHex(string data)
        {
            //Split packet data by end of lines, remove first 3 - unnecessary data generated by PrintHex method, remove empty lines
            //then remove first 6 characters from each line - 'data: ' generated by PrintHex and then join by \n
            return string.Join("\n", data.Split("\n").Skip(3).Where(x => x.Length != 0).Select(x => "0x" + x[6..]));
        }
        /// <summary>
        /// Print tcp, udp, icmp or arp packet in correct format to stdout
        /// </summary>
        /// <param name="packet">Parsed ethernet frame to Packet data type</param>
        /// <param name="arrivalTime">Packed captured time</param>
        public static void PrintPacket(Packet packet, DateTime arrivalTime)
        {
            string formattedPacket = "";
            if (packet.PayloadPacket is IPPacket)
            {
                var ipPacket = packet.Extract<IPPacket>();
                int? destPort = null, sourcePort = null;
                if (ipPacket.PayloadPacket is UdpPacket || ipPacket.PayloadPacket is TcpPacket)
                {
                    destPort = ipPacket.PayloadPacket is UdpPacket ? ipPacket.Extract<UdpPacket>().DestinationPort : ipPacket.Extract<TcpPacket>().DestinationPort;
                    sourcePort = ipPacket.PayloadPacket is UdpPacket ? ipPacket.Extract<UdpPacket>().SourcePort : ipPacket.Extract<TcpPacket>().SourcePort;
                }
                formattedPacket = PacketHeader(arrivalTime, ipPacket.SourceAddress, sourcePort, ipPacket.DestinationAddress,
                    destPort, packet.TotalPacketLength);
                formattedPacket += PacketDataHex(ipPacket.PrintHex());

            }
            else if (packet.PayloadPacket is ArpPacket)
            {
                var arpPacket = packet.Extract<ArpPacket>();
                formattedPacket = PacketHeader(arrivalTime, arpPacket.SenderProtocolAddress, null, arpPacket.TargetProtocolAddress, null,
                    packet.TotalPacketLength);//arp packet has no port - null
                formattedPacket += PacketDataHex(arpPacket.PrintHex());
            }

            Console.WriteLine($"{formattedPacket}\n"); //new line after packet to separate next packet data
        }

        /// <summary>
        /// Capture n packets filtered by arguments and print to stdout
        /// </summary>
        /// <param name="Interface">Interface to capture packets at</param>
        /// <param name="p">Dest or source port of packets to capture</param>
        /// <param name="tcp">Capture tcp packets</param>
        /// <param name="udp">Capture udp packets</param>
        /// <param name="icmp">Capture icmp packets</param>
        /// <param name="arp">Capture arp frames</param>
        /// <param name="n">Number of packets to display</param>
        public static void SniffPackets(string Interface, int? p, bool tcp, bool udp, bool icmp, bool arp, int n)
        {
            var devices = CaptureDeviceList.Instance;
            if (Interface == "") //if interface is not entered, print list of all interfaces
            {
                foreach (var device in devices)
                {
                    Console.WriteLine(device.Name);
                }
                return;
            }
            if (devices.All(x => x.Name != Interface)) //none of interfaces matches argument
            {
                Console.Error.WriteLine("Given interface does not exist");
                Environment.Exit(1);
            }

            var deviceToSniff = devices.Single(x => x.Name == Interface);
            deviceToSniff.Open();
            deviceToSniff.Filter = "";
            if (!(tcp || udp || icmp || arp)) //none of these arguments = capture all
            {
                if (p == null)
                {
                    deviceToSniff.Filter = "arp or icmp or tcp or udp";
                }
                else //specify port of captured packets
                {
                    deviceToSniff.Filter = $"arp or icmp or ((tcp or udp) and port {p})";
                }
            }
            else //set filter by options combination
            {
                if (tcp)
                {
                    deviceToSniff.Filter = "tcp";
                }
                if (udp)
                {
                    deviceToSniff.Filter += deviceToSniff.Filter == "" ? "udp" : " or udp";
                }
                if (p != null)
                {
                    if (deviceToSniff.Filter == "") //Tcp or Udp must be selected to capture to filter port
                    {
                        Console.Error.WriteLine("icmp and arp have no port");
                        Environment.Exit(1);
                    }
                    else
                    {
                        deviceToSniff.Filter = $"(({deviceToSniff.Filter}) and port {p})";
                    }
                }
                if (icmp)
                {
                    deviceToSniff.Filter += deviceToSniff.Filter == "" ? "icmp" : " or icmp";
                }
                if (arp)
                {
                    deviceToSniff.Filter += deviceToSniff.Filter == "" ? "arp" : " or arp";
                }

            }
            var i = 0;
            while (i < n) //capture only n packets
            {
                var capture = deviceToSniff.GetNextPacket();
                if (capture == null)
                {
                    continue;
                }
                if (capture.LinkLayerType != LinkLayers.Ethernet)
                {
                    continue;
                }
                PrintPacket(Packet.ParsePacket(LinkLayers.Ethernet,capture.Data), capture.Timeval.Date);
                i++;
            }
            deviceToSniff.Close();
        }   

        static void Main(string[] args)
        {

            var rootCommand = new RootCommand
            {
                new Option<int?>("-p", getDefaultValue: () => null, description: "Specify port of packets to be displayed"),
                new Option<bool>(new[] {"--tcp", "-t"}, description: "filter tcp packets"),
                new Option<bool>(new[] {"--udp", "-u"}, description: "filter udp packets"),
                new Option<bool>("--icmp", description: "filter icmp packets"),
                new Option<bool>("--arp", description: "filter arp frames"),
                new Option<int>("-n", getDefaultValue:() => 1, description: "number of packets to display")
            };
            var interfaceOption = new Option<string>("--interface", "Interface where packets should be sniffed", arity: ArgumentArity.ZeroOrOne);
            interfaceOption.AddAlias("-i");
            rootCommand.AddOption(interfaceOption);
            //pass parsed arguments to SniffPacket
            rootCommand.Handler = CommandHandler.Create<string, int?, bool, bool, bool, bool, int>(SniffPackets);
            rootCommand.Invoke(args);
        }
    }
}
